/**
* 小明想要处理一批图片，将相似的图片分类。他首先对图片的特征采样
 * ，得到图片之间的相似度，然后按照以下规则判断图片是否可以归为一类：
 *
 * 相似度>0表示两张图片相似，如果A和B相似，B和C相似，但A和C不相似。
 * 那么认为A和C间接相似，可以把ABC归为一类，但不计算AC的相似度
 * 如果A和所有其他图片都不相似，则A自己归为一类，相似度为0
 *
 * 给定一个大小为NxN的矩阵M存储任意两张图片的相似度，
 * M[i][j]即为第i个图片和第j个图片的相似度，
 * 请按照"从大到小”的顺序返回每个相似类中所有图片的相似度之和。

 * 解答要求
 * 时间限制: C/C++ 1000ms,其他语言: 2000ms内存限制: C/C++ 256MB,其他语言: 512MB

 * 输入
 * 第一行一个数N，代表矩阵M中有N个图片，
 * 下面跟着N行，每行有N列数据，空格分隔(为了显示整弃，空格可能为多个) 代表N个图片之间的相似度。
 * 0<N<=900
 * 0<=M[i][j]<=100,输入保证M[i][i] =0,M[i][j]=M[j][i]

 * 输出
 * 每个相似类的相似度之和。格式为:一行数字，分隔符为1个空格。

 eg
 * input:
		5
		0 0 50 0 0
		0 0 0 25 0
		50 0 0 0 15
		0 25 0 0 0
		0 0 15 0 0
 * output:
		65 25
*/

/**
 * 典型的深度优先搜索，参考leetcode 岛屿的数量，
 * 一方面要遍历出图中，有几个连通域， 遍历过程中，要对元素进行标记，表示访问过
 * 另一方面要计算出连通域中的相似度
 */

#include <iostream>
#include <vector>

using namespace std;

int main() {
	vector<vector<int>> M;
	int n;
	cin >> n;
	cin.get();
	for (int i = 0; i < n; i++) {
		vector<int> tmp;
		int x;
		while (cin >> x) {
			tmp.push_back(x);
			if (cin.get() == '\n') break;
		}
		M.push_back(tmp);
	}


}