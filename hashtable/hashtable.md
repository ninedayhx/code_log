# 哈希表
## 基本理论
一般哈希表都是用来快速判断一个元素是否出现集合里。

哈希结构可以有以下三种数据结构
- 数组
  - 数组的key就是数组的下标，value就是数组的内容，可以以O(1)的方式查询
- 集合(set)
  - 集合的意义与数学中的集合意义一致，集合不同于映射,其存储的每一个元素都只包含一个key值,key值必须唯一
- 映射(map)
  - 映射是指的key->value，即存储的元素包含一个key值以及对应的value,在映射中，key值必须唯一，但是value可以不同

## 数组如何作为哈希表
举例，比如说统计字符串中，某些字符的出现次数，由于字符串中的字符符合ascii编码，为0-128，所以需要直接使用字符的asci值
作为数组的下标，数组的内容就是该字符的出现次数。

## set

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | --- | --- | --- | --- | --- |
| std::set | 红黑树 | 有序 | 否 | 否 | O(log n) | O(log n) |
| std::multiset | 红黑树 | 有序 | 是 | 否 | O(logn) | O(logn) |
| std::unordered\_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树
，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，
改动key值会导致整棵树的错乱，所以只能删除和增加。

这里所谓的无序指的是按存入的顺序排列，这里的有序指的是，内部数据排列按key的大小排列

## map

| 映射 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| --- | --- | --- | --- | --- | --- | --- |
| std::map | 红黑树 | key有序 | key不可重复 | key不可修改 | O(logn) | O(logn) |
| std::multimap | 红黑树 | key有序 | key可重复 | key不可修改 | O(log n) | O(log n) |
| std::unordered\_map | 哈希表 | key无序 | key不可重复 | key不可修改 | O(1) | O(1) |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。
同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。